CLASS fo net/minecraft/core/BlockPos
	FIELD a ZERO Lfo;
	FIELD c LOGGER Lorg/apache/logging/log4j/Logger;
	FIELD d PACKED_X_LENGTH I
	FIELD e PACKED_Z_LENGTH I
	FIELD f PACKED_Y_LENGTH I
	FIELD g PACKED_X_MASK J
	FIELD h PACKED_Y_MASK J
	FIELD i PACKED_Z_MASK J
	FIELD j Z_OFFSET I
	FIELD k X_OFFSET I
	METHOD <clinit> <clinit> ()V
	METHOD <init> <init> (DDD)V
	METHOD <init> <init> (III)V
	METHOD <init> <init> (Lddp;)V
	METHOD <init> <init> (Lgf;)V
	METHOD <init> <init> (Lgo;)V
	METHOD a asLong ()J
	METHOD a offset (DDD)Lfo;
	METHOD a multiply (I)Lfo;
	METHOD a asLong (III)J
	METHOD a betweenClosedStream (IIIIII)Ljava/util/stream/Stream;
	METHOD a lambda$withinManhattan$3 (IIIIIII)Ljava/util/Iterator;
	METHOD a isOutsideBuildHeight (J)Z
	METHOD a offset (JIII)J
	METHOD a offset (JLft;)J
	METHOD a rotate (Lbyv;)Lfo;
	METHOD a deserialize (Lcom/mojang/datafixers/Dynamic;)Lfo;
	METHOD a serialize (Lcom/mojang/datafixers/types/DynamicOps;)Ljava/lang/Object;
	METHOD a betweenClosedStream (Lcsw;)Ljava/util/stream/Stream;
	METHOD a withinManhattan (Lfo;III)Ljava/lang/Iterable;
	METHOD a findClosestMatch (Lfo;IILjava/util/function/Predicate;)Ljava/util/Optional;
	METHOD a betweenClosed (Lfo;Lfo;)Ljava/lang/Iterable;
	METHOD a relative (Lft$a;I)Lfo;
	METHOD a relative (Lft;)Lfo;
	METHOD a relative (Lft;I)Lfo;
	METHOD a offset (Lgo;)Lfo;
	METHOD a lambda$deserialize$2 ([II)V
	METHOD b above ()Lfo;
	METHOD b offset (DDD)Lgo;
	METHOD b above (I)Lfo;
	METHOD b offset (III)Lfo;
	METHOD b betweenClosed (IIIIII)Ljava/lang/Iterable;
	METHOD b getX (J)I
	METHOD b withinManhattanStream (Lfo;III)Ljava/util/stream/Stream;
	METHOD b betweenClosedStream (Lfo;Lfo;)Ljava/util/stream/Stream;
	METHOD b relative (Lft$a;I)Lgo;
	METHOD b relative (Lft;)Lgo;
	METHOD b relative (Lft;I)Lgo;
	METHOD b subtract (Lgo;)Lfo;
	METHOD b lambda$deserialize$1 ([II)V
	METHOD c below ()Lfo;
	METHOD c below (I)Lfo;
	METHOD c offset (III)Lgo;
	METHOD c lambda$betweenClosed$4 (IIIIII)Ljava/util/Iterator;
	METHOD c getY (J)I
	METHOD c cross (Lgo;)Lfo;
	METHOD c lambda$deserialize$0 ([II)V
	METHOD d north ()Lfo;
	METHOD d north (I)Lfo;
	METHOD d getZ (J)I
	METHOD d cross (Lgo;)Lgo;
	METHOD e south ()Lfo;
	METHOD e south (I)Lfo;
	METHOD e of (J)Lfo;
	METHOD e subtract (Lgo;)Lgo;
	METHOD f west ()Lfo;
	METHOD f west (I)Lfo;
	METHOD f getFlatIndex (J)J
	METHOD f offset (Lgo;)Lgo;
	METHOD g east ()Lfo;
	METHOD g east (I)Lfo;
	METHOD h immutable ()Lfo;
	METHOD h east (I)Lgo;
	METHOD i mutable ()Lfo$a;
	METHOD i west (I)Lgo;
	METHOD j east ()Lgo;
	METHOD j south (I)Lgo;
	METHOD k west ()Lgo;
	METHOD k north (I)Lgo;
	METHOD l south ()Lgo;
	METHOD l below (I)Lgo;
	METHOD m north ()Lgo;
	METHOD m above (I)Lgo;
	METHOD n below ()Lgo;
	METHOD n multiply (I)Lgo;
	METHOD o above ()Lgo;
	CLASS 1 1
		FIELD a val$originZ I
		FIELD b val$maxDepth I
		FIELD c val$reachX I
		FIELD d val$reachY I
		FIELD e val$reachZ I
		FIELD f val$originX I
		FIELD g val$originY I
		FIELD h cursor Lfo$a;
		FIELD i currentDepth I
		FIELD j maxX I
		FIELD k maxY I
		FIELD l x I
		FIELD m y I
		FIELD n zMirror Z
		METHOD <init> <init> (IIIIIII)V
		METHOD a computeNext ()Lfo;
		METHOD computeNext computeNext ()Ljava/lang/Object;
	CLASS 2 2
		FIELD a val$end I
		FIELD b val$width I
		FIELD c val$height I
		FIELD d val$minX I
		FIELD e val$minY I
		FIELD f val$minZ I
		FIELD g cursor Lfo$a;
		FIELD h index I
		METHOD <init> <init> (IIIIII)V
		METHOD a computeNext ()Lfo;
		METHOD computeNext computeNext ()Ljava/lang/Object;
	CLASS 3 3
		FIELD a $SwitchMap$net$minecraft$world$level$block$Rotation [I
		METHOD <clinit> <clinit> ()V
	CLASS a MutableBlockPos
		METHOD <init> <init> ()V
		METHOD <init> <init> (DDD)V
		METHOD <init> <init> (III)V
		METHOD a offset (DDD)Lfo;
		METHOD a multiply (I)Lfo;
		METHOD a rotate (Lbyv;)Lfo;
		METHOD a set (Lfm;III)Lfo$a;
		METHOD a relative (Lft$a;I)Lfo;
		METHOD a relative (Lft;I)Lfo;
		METHOD a setWithOffset (Lgo;III)Lfo$a;
		METHOD a setWithOffset (Lgo;Lft;)Lfo$a;
		METHOD a setWithOffset (Lgo;Lgo;)Lfo$a;
		METHOD b offset (DDD)Lgo;
		METHOD b offset (III)Lfo;
		METHOD b relative (Lft$a;I)Lgo;
		METHOD b relative (Lft;)Lgo;
		METHOD b relative (Lft;I)Lgo;
		METHOD c set (DDD)Lfo$a;
		METHOD c offset (III)Lgo;
		METHOD c move (Lft;)Lfo$a;
		METHOD c move (Lft;I)Lfo$a;
		METHOD d set (III)Lfo$a;
		METHOD d cross (Lgo;)Lgo;
		METHOD e move (III)Lfo$a;
		METHOD e subtract (Lgo;)Lgo;
		METHOD f offset (Lgo;)Lgo;
		METHOD g set (J)Lfo$a;
		METHOD g set (Lgo;)Lfo$a;
		METHOD h immutable ()Lfo;
		METHOD h east (I)Lgo;
		METHOD h move (Lgo;)Lfo$a;
		METHOD i west (I)Lgo;
		METHOD j east ()Lgo;
		METHOD j south (I)Lgo;
		METHOD k west ()Lgo;
		METHOD k north (I)Lgo;
		METHOD l south ()Lgo;
		METHOD l below (I)Lgo;
		METHOD m north ()Lgo;
		METHOD m above (I)Lgo;
		METHOD n below ()Lgo;
		METHOD n multiply (I)Lgo;
		METHOD o above ()Lgo;
		METHOD o setX (I)V
		METHOD p setY (I)V
		METHOD q setZ (I)V
